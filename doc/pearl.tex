\documentclass{article}

\usepackage{todonotes}

\usepackage[authoryear]{natbib}
\bibliographystyle{apalike}

\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}

% grab parts of other files
\usepackage{catchfilebetweentags}
\input{robust-catch}

% tree diagrams
\usepackage{tikz}
\usetikzlibrary{matrix}

% algorithm
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}


\usepackage{cleveref}

\title{Certified Binary Search in a Read-Only Array}
\author{Guillaume ALLAIS}

\begin{document}
\maketitle

\begin{abstract}
  Reifying the control flow of imperative programs as data structures allows
  functional programmers to implement common algorithms by an obviously
  terminating structural recursion. Additionally, this inductive structure
  can be decorated with invariants allowing the procedure to be proven correct.

  This ease of definition and certification comes at a cost because the
  functional data structure is typically not stored as efficiently in
  memory as the imperative counterpart it replaces.

  In this paper we use quantitative type theory as implemented in Idris2 to
  combine an efficient runtime representation of the data with a convenient
  compile time inductive view of it to use for ease of definition and
  certification.
\end{abstract}

\section{Introduction}

One of the strengths of functional programming is the ability to reify common
control flow structures as inductive types and replace the corresponding ad-hoc
iteration constructs by recursive functions consuming these inductively defined
values.

This is perhaps best exemplified by the \texttt{forM} construct which provides
users with a convenient replacement for a \texttt{for} loop iterating over a
range of values.
%
Instead of writing \texttt{for(i = 0; i <= 10; i=i+2) body} to execute
\texttt{body} with \texttt{i} taking the successive values $0$, $2$, etc. up to
$10$, the user can first write \texttt{[0,2..10]} to generate a list
corresponding to the range of interest and then iterate over it with
\texttt{forM} thus getting the equivalent program
\texttt{forM [0,2..10] \$ \textbackslash i -> body}.

Replacing equals for equals is of course not the most exciting.
%
A first comparative advantage of the functional approach is the fact that any
function or system call producing a list of values (not just integers!) can now
become a source of control flow.
%
The second and perhaps more important one comes from the fact that these
constructs can then be extended to work with a whole \emph{class} of inductive
types thus generalising the original iteration principle.
%
In Haskell's standard library, \texttt{forM} will for instance work over not
just lists but more generally any \texttt{Traversable}
type~\citep{DBLP:journals/jfp/McbrideP08},
that is to say any finitely branching tree-like structure.

This generalisation can unfortunately come at a cost. If Haskell's optimiser is
good enough to generate tight loops for programs similar to the one above, it
will not be able to avoid the extra allocations and pointer chasing introduced by
the use of an inductive data type in all cases. We will consider one such case in
\cref{example:search}.

The work on LoCal, a functional language whose types carry information about the
runtime data-layout of the recursive structures being traversed, attempts to solve
that problem. The careful typing rules ensure the user-written programs manipulating
inductive data can be run directly on its serialised form.
%
In it, \citet{DBLP:conf/pldi/VollmerKRS0N19} warn against the explicit manipulation
of pointers. This justifies their approach: adding built-in compiler support.

\begin{quote}
  Cursors need to be manipulated carefully to visit the necessary portions
  of the buffer skipping over the sections that are not needed and read out
  the appropriate data, all without the safety net of a type checker. Hence,
  writing code to work directly on the serialized data can be tedious and
  error-prone.
\end{quote}

As we are going to see in this paper, from the point of view of the dependently
typed programmer this special built-in support is redundant.
%
In the same way that data-generic programming is usual programming over a closed
universe of descriptions of data types~\citep{DBLP:conf/ifip2-1/AltenkirchM02},
programming over serialised data is usual programming over data that is aware
of its serialisation format.

\subsection{Roadmap}\todo{expand}

In this pearl we will focus on a specific algorithm: binary search in a
sorted read-only array. This is typically used to efficiently check whether
a given value belongs to a set.

\paragraph{Section \ref{sec:reconstruct}} is dedicated to rediscovering the
underlying structure of search by dichotomy. It leads us to the corresponding
functional abstraction using a binary search tree.

\paragraph{Section \ref{sec:qtt}} is a quick introduction to the quantitative
type theory underpinning Idris2 and the notion of runtime irrelevance that it
provides.

\paragraph{Section \ref{sec:treearray}} is the core of our pearl: the
runtime irrelevant inductive structure that allows us to see a read-only array
as a tree in disguise. All of the information it carries allows us to prove a
logarithmic \emph{decidability} principle for array membership.


\section{Search by dichotomy}
\label{sec:reconstruct}

Binary search is a classic example of an algorithm offering an asymptotic
improvement over a naïve approach, under the assumption that the input data
is structured.
%
Provided a set represented as an array that is known to be sorted, it is
possible to test set membership in logarithmic time instead of taking linear
time to compare the value of interest to each value in the set.

The key observation underpinning this algorithm is that, by virtue of the array
being sorted, the value in the middle of any subarray divides it in two parts:
the left one, only containing strictly smaller values,
and the right one, only containing strictly larger ones.
%
Using this knowledge, at each step of the procedure we can eliminate half of
the remaining candidates. Comparing the value in the middle of the subarray
we are focused on with our value of interest, we can
either stop if we have successfully found our target
or focus on the left or the right half of the subarray depending on whether
our target is smaller or larger than the value we just read.

Let us look at a couple of executions of this search algorithm on a set
represented as a sorted array.

\subsection{Search, by example}
\label{example:search}

In figure~\ref{fig:searchsuccess} we are looking for
the value 11 in a sorted array which happens to contain the first
ten prime numbers.
%
We start by reading the value in the middle of the whole array, find out it is
13 which is larger than 11 and thus focus on the left half of the array for the
next step.
%
We then read the value in the middle of this left half, obtain 5
which is smaller than 11 and thus shift our focus to the right of 5, that is
to say on the second quarter of the whole array.
%
After reading 7, we shift once more our focus to the right and finally manage
to find our target. The search for 11 was successful.

\begin{figure}[h]
  \center
  \ExecuteMetaData[tree.tex]{search11}
  \caption{Tracing the binary search for 11}
  \label{fig:searchsuccess}
\end{figure}

If we had been looking for the value 31 instead, we would have obtained the
unsuccessful trace shown in figure~\ref{fig:searchfail}. We start from the
middle of the array and repeatedly shift our focus to the right because we
keep reading numbers smaller than our target. We eventually reach the end of
the array and can declare that 31 is not a member of the set.


\begin{figure}[h]
  \center
  \ExecuteMetaData[tree.tex]{search31}
  \caption{Tracing the binary search for 31}
  \label{fig:searchfail}
\end{figure}

\subsection{Search, imperatively}


\input{algo}

\subsection{The computation's underlying structure}

This listing gives us a formal definition of the algorithm. It should be
enough to prove it terminating and correct under the assumption that the
input array is sorted.
%
However it has not shone any light on the structure of the computation.
If a list of values is the essence of a \texttt{for} loop,
what is that of a search by dichotomy?
%
This can be answered by going back to our running example and taking the
time to observe the behaviour of binary search tree.

In figure \ref{fig:searchall} we trace all of the possible execution paths
and see a tree revealed.
%
This is the underlying structure of the binary search computation: a binary
search tree! Additionally, because the procedure is guaranteed to halve the
number of candidates at each step, we know that this binary search tree is
balanced.\todo{Be precise: AVL?}

\begin{figure}[h]
  \center
  \ExecuteMetaData[tree.tex]{searchall}
  \caption{Tracing all possible binary searches}
  \label{fig:searchall}
\end{figure}

This suggests a straightforward avenue for implementation in a functional
language or formalisation in a proof assistant: ditch the array and use the
underlying binary search tree instead!
%
This has the added benefit of replacing an unwieldy induction over the size
of the subarray in focus in favour of a purely structural one on the tree.

Additionally, in a dependently typed language we can annotate the tree with
invariants thus guaranteeing that the values are indeed sorted. This empowers
us to not only write a search procedure but also prove that it decides the
set membership problem.

However this would have adverse consequences in terms of performance: instead of
a compact representation using a contiguous array, we now have a tree whose
nodes comprise of a value and two pointers to its children.

Can we have the best of both worlds? A compact runtime representation using an
array and an obviously terminating recursive decision procedure?
%
We will decidedly answer yes in section~\ref{sec:treearray} thanks to the tools
we are going to introduce now.


\section{QTT and Runtime Irrelevance}
\label{sec:qtt}



\section{A Tree in Disguise}
\label{sec:treearray}



\section{Related work}

\paragraph{LoCal}

\todo{Check Bedrock}
\todo{Check ghosts of departed proofs}

\bibliography{pearl}

\end{document}
